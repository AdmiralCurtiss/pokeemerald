Blocks 0x00-0x0D -> First save
Blocks 0x0E-0x1B -> Second save
Block 0x1C -> Hall of Fame part 1.
Block 0x1D -> Hall of Fame part 2.
Block 0x1E -> Japanese version seems to use this for the e-Card data for Trainer Hill. Unused in International versions? 
Block 0x1F -> Recorded battle.


PLAN OF ACTION:
 - Select a 64 KB flash.
 - Stub bank switching. Panic if high bank is selected.
 - Skip reading save slot 2, always claim it's older.
 - Modify the mod 2 of save number to always select slot 1 on saving. (Search for gUnknown_03006200)
 - Reduce hall of fame max to 32 slots (both on reading and writing).
 - Read hall of fame in sector 0xE twice or stub second read.
 - Write hall of fame in sector 0xE for the first half, stub the write for the second half.
 - Stub trainer hill reading and writing.
 - Read and write battle recordings to sector 0xF.

 
Change FLASH1M_V103 to FLASH512_V131 in output file, some emulators need this for autodetection of save type.

To stub the bank switching & panic on high bank put the following data at 0x02E1860: 00 28 08 D0 FE E7 C0 46 C0 46 C0 46 C0 46 C0 46 C0 46 C0 46 C0 46

Corresponds to ASM code:
	[unchanged lsl/lsr of SwitchFlashBank]
	cmp r0, #0
	beq ._SWITCHBANKEND
._SWITCHBANKPANIC:
	b ._SWITCHBANKPANIC
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
._SWITCHBANKEND:
	[unchanged bx of SwitchFlashBank]

In other words, we intentionally hang if someone selects a non-0 bank, and just return otherwise.

Checksums of result:
CRC32: 8AC0DBE1
MD5: 59f5c1a16a78c7cf5e9f0ed8e0f09741
SHA1: 73fbd426c117a3c5f4b180d648888c19a5d4c19e
SHA256: 65c20a483a85382b23e05f777b70076b5ba145b6b32fc5ca2df008d8719722bc
SHA512: 82193d81c9c494c9c7a8d0e7e64af24bfb74acc7b22a1c92ce53f3c37c0d463477af6867f20be7557af3d58dca413e1ddf71670ed6eca8be85f69ef0ad83960d



Tech details:

The game stores the current number of saves in 0x03006200 and does a mod 2 on it to figure out if the current save is in slot 0 or 1. I modified those calculations to always select slot 0, even though I'm not entirely sure what some of the functions are used for.

1x @ 0x81527CC -> Always select the first save slot when determining the slot to write to.
1x @ 0x8152AAC -> Always select the first save slot in this undetermined function.
1x @ 0x8152C42 -> Always select the first save slot in this undetermined function.
1x @ 0x8152CD0 -> Always select the first save slot in this undetermined function.
1x @ 0x8152D68 -> Always select the first save slot in this undetermined function.
1x @ 0x8152E1E -> Always select the first save slot in this undetermined function.

On game init, the game reads both save slot, determines which of them are valid and which one is newer then the other (via the save counter).

5x @ 0x8152F7C -> The read of the second save slot has been replaced to always report that the second slot is the same validity as the first slot (so you still get correct system messages for corruption and stuff), and that the second slot is always one save older than the first slot, so the game will never pick it when deciding which slot to load.

After the Elite 4, the game calls a special function to save the game and record the current team in the Hall of Fame. Normally, the Hall of Fame occupies two sectors of flash memory, 0x1C and 0x1D, and stores a maximum of 50 teams. With a 512K flash, we only have two spare sectors for extra data, and we still need a place to hold the recorded battles from the Battle Frontier, so I've modified the Hall of Fame reads and writes to only store 32 teams and only use one flash sector, 0x0E.

1x @ 0x8153244, 2x @ 0x8153256 -> When Hall of Fame data has to be erased for whatever reason, only erase sector 0xE.
1x @ 0x815327E -> Save the first half of the Hall of Fame to sector 0xE instead of 0x1C.
2x @ 0x8153290 -> Remove the write to sector 0x1D. By limiting the Hall of Fame to 32 teams, the second half is always empty and doesn't need to be written.
1x @ 0x81532F8, 2x @ 0x815330A -> Again, when Hall of Fame data has to be erased for whatever reason, only erase sector 0xE.
2x @ 0x815352E -> Load the first half of the Hall of Fame from sector 0xE instead of 0x1C.
7x @ 0x8153540 -> memset the second half of the Hall of Fame to 0 instead of reading it from sector 0x1D.

1x @ 0x815359A -> Always select the first save slot in this undetermined function.

The Battle Frontier battle recording usually saves to sector 0x1F. I remapped it to sector 0xF.

2x @ 0x81535EC -> This seems like a sanity check that determines if the requested sector is either 0x1E or 0x1F and returns from the function with failure if it's not. Since 0xF is outside that range, I modified the check to just check for sector 0xF.
2x @ 0x8153644 -> Same sanity check.

1x @ 0x8173922 -> Change the maximum amount of saved hall of fame records from 50 to 32.
1x @ 0x8173930 -> Same as above.
1x @ 0x817438C -> Change the maximum amount of loaded hall of fame records from 50 to 32.
1x @ 0x817439A -> Same as above.
1x @ 0x81743C4 -> Same as above.

1x @ 0x81795D2 -> Modify function that (re?)initializes the entire save file to only write to 0x10 sectors we now have instead of the 0x20 sectors we had.

1x @ 0x818531C -> Write to sector 0xF instead of 0x1F for the Battle Frontier's battle recording.
1x @ 0x8185A58 -> Read from sector 0xF instead of 0x1F for the Battle Frontier's battle recording.

In the Japanese version of the game, the Trainer Hill on Route 111 worked by scanning e-Cards that modified the trainer setups and floor layouts of the tower. The data for the currently scanned cards was stored in Flash sector 0x1E. In the International versions of the game, the Trainer Hill was modified to just contain a few pre-set layouts, so Flash sector 0x1E seems to be unused in those versions. Just in case, I've dummied out the leftover reads and writes to that sector.

2x @ 0x81D3A92 -> If, somehow, the Trainer Hill save write function is ever called, don't call the flash write function and just claim the write failed.
2x @ 0x81D3AE0 -> Likewise, if the Trainer Hill save read function is called, don't call the flash read and just claim the read failed. This one is actually still called when Trainer Hill starts in the English version, but of course doesn't actually seem to do anything.

Access to Flash memory:

Bx @ 0x82E1860 -> Completely rewrite SwitchFlashBank. It now does nothing if bank 0 is selected, but hangs the game when a higher bank is selected, so we can figure out if we missed a place where the save file is accessed. This also serves as a protection for writes that would hit flash bank 1, since on devices/emulators that don't understand flash banks they would hit bank 0 and corrupt the data in it.
1x @ 0x82E1AF8 -> ReadFlash checks for a 1M Flash size before calling SwitchFlashBank. This check has been modified so that SwitchFlashBank is still called for the 512K Flash.
1x @ 0x82E1BC0 -> Same as above for VerifyFlashSector.
1x @ 0x82E1C4C -> Same as above for VerifyFlashSectorNBytes.
Note that the Program and Erase functions always call SwitchFlashBank regardless of Flash size, probably because they're supposed to be flash type specific.

Finally, I modified the Flash identification string at 0x89A30C0 to claim a 512K flash (I suspect these are unused on actual hardware, but some emulators use them to detect save type), and modified and a few flash IDs and sizes below that to match the data a real 512K GBA flash memory would have.

If the device or emulator you're using this patch on does not save or boot correctly, you can try modifying the known Flash IDs, which are two bytes each at 0x9A3148 and 0x9A31E0. Reference the table at http://problemkaputt.de/gbatek.htm#gbacartbackupflashrom for valid IDs. As a last resort, you can also change the 0x03 at 0x82E1D94 to a 0x02, which changes the IdentifyFlash function to report flash identification success even though the ID wasn't recognized, though I have no idea if that actually works.



Updates to version 1.1:

Checksums of result:
CRC32: E7B0C2AC
MD5: 37b82fea4b90616203b59fbe33e36acd
SHA1: 2c49b5ea3ae018da7831e86ab053f2a1bd894ef6
SHA256: e65bcfaa63fee006dd8ab785c6d52de9a7681b89777f7d19d08b58979e7856eb
SHA512: 9ba097996e89016e06c7c92f4de0ea5d4cab22b1d9bd2d2f0cdf4d861e076368148800fc962b8832448cf5b6121e650a37d2b242754eb0e90cb619dac0abf16d


A lot @ 0x8152F88 -> The memory of the instructions of the read of the second save slot (which are just skipped over now) has been repurposed to hold two extra flash chip identification structures.

2x @ 0x82E1AF8 -> The check if SwitchFlashBank needs to be called has been changed again, this time to call SwitchFlashBank whenever the flash size is not 64 MB, which is nonsensically huge. The idea is to always call SwitchFlashBank regardless of flash size without altering the code much.
2x @ 0x82E1BC0 -> Same as above.
2x @ 0x82E1C4C -> Same as above.

pointers @ 0x02E1D84 and 0x09A30DC: Change the pointer to the location of the array of flash chip identification structures in IdentifyFlash to the new, bigger one (see below).

Reverted the two original flash chip identification structures at 0x89A311C and 0x89A31C8 back to the default, mostly. The last one references a structure at 0x09A31A0 which is just a copy of the structure at 0x09A3104 that the other one uses, so I pointed it at that to reuse the structure at 0x09A31A0. Additionally, 0x89A314C was the fallback flash chip identification structure used in case the detected flash chip matches none of the types we know about. It has been repurposed as a fifth actual structure. There is no longer a fallback, in case of not detecting we just use the first one in the pointer array (which is the SST 512K). Not like there is much point to the fallback case, the game seems to intentionally hang if the detection fails.

The structure at 0x09A31A0 is now used as a bigger array of pointers to flash chip identification structures, as the original was just 3 entries large -- the new one is 6. The original array at 0x09A30D0 is still there, but now unused, and could be repurposed if the need arises for a little bit of extra memory.

The six entries are, in order:
- Pointer to 0x8152F88, data for the SST 512K flash chip. (was instructions for read of second save slot)
- Pointer to 0x8152FB8, data for the Macronix 512K flash chip. (was instructions for read of second save slot)
- Pointer to 0x89A314C, data for the Panasonic 512K flash chip. (was fallback structure)
- Pointer to 0x89A311C, data for the Macronix 1M flash chip. (unchanged from original game)
- Pointer to 0x89A31C8, data for the Sanyo 1M flash chip. (unchanged from original game)
- Null pointer to indicate end of array.

To make this work, the loop to find the structure of the detected chip in IdentifyFlash has been modified:

0x82E1D8C: 00 29 02 D1 14 3A 01 24 03 E0
changes the 'flash chip unknown' cancel reason from 'maker is 0' to 'nullptr encountered'
cmp r1,0h    // if not nullptr
bne 82E1D96h // continue loop as normal
sub r2,14h   // else select the info of the first flash chip
mov r4,1h    // report failure
b   92E1D9Eh // and break out of loop

Scholars of GBA hardware may notice that I did not list the Atmel 512K flash chip. Due to the odd properties of that chip compared to the other five, I have decided to not support it. Hopefully this is not a problem.



